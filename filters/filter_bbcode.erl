%% @author Dmitrii Dimandt <dmitrii@dmitriid.com>
%% @copyright 2011 Dmitrii Dimandt
%% @doc 'bbcode' filter, transform bbcode to html

%% Copyright 2011 Dmitrii Dimandt
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%% 
%%     http://www.apache.org/licenses/LICENSE-2.0
%% 
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.

% 
% {{ text|bbcode }}
%
% This is a very simple filter. It only implements tags described here:
% http://en.wikipedia.org/wiki/BBCode
%
% There's only one small addition:
%
% [table][thead][th]header[/th][/thead][tr][td]cell[/td][/tr][/table]
%
% will generate a table with <th>'s
%
%
% The filter was generated using Neotoma, a PEG parser genrator,
% https://github.com/seancribbs/neotoma
%
% You can find PEG Grammar for BBCode below.
%
% The filter was generated using two files by running
%   neotoma:file("bbcode.peg", [{transform_module, bbcode_ast}])
% against the grammar and then merging bbcode.erl and bbcode_ast, which defines custom 
% transformation rules, into one file.
%
% Enjoy!
%

-module(filter_bbcode).
-export([bbcode/2]).

-compile(nowarn_unused_vars).
-compile({nowarn_unused_function,[p/4, p/5, p_eof/0, p_optional/1, p_not/1, p_assert/1, p_seq/1, p_and/1, p_choose/1, p_zero_or_more/1, p_one_or_more/1, p_label/2, p_string/1, p_anything/0, p_charclass/1, line/1, column/1]}).



bbcode(undefined, _Context) ->
    undefined;

bbcode(Text, _Context) ->
	lists:flatten(parse(Text)).


%% 
%% Custom parse rules for BBCode PEG Grammar parser generated by Neotoma.
%%
%% See PEG grammar below these rules
%%

transform1(Symbol, Node, _Index) when is_atom(Symbol) ->
  transform2(Symbol, Node, _Index).

transform2('Em', Node, _Index) ->
  ["<em>", lists:flatten(lists:nth(2, Node)), "</em>"];

transform2('Strong', Node, _Index) ->
  ["<strong>", lists:nth(2, Node), "</strong>"];

transform2('Underline', Node, _Index) ->
  ["<u>", lists:nth(2, Node), "</u>"];

transform2('Strike', Node, _Index) ->
  ["<s>", lists:nth(2, Node), "</s>"];

transform2('Url', Node, _Index) ->
  Url = lists:nth(2, Node),
  ["<a href=\"", Url, "\">", Url, "</a>"];

transform2('UrlTag', Node, _Index) ->
  Url = lists:nth(2, Node),
  Text = lists:nth(4, Node),
  ["<a href=\"", Url, "\">", Text, "</a>"];

transform2('Img', Node, _Index) ->
  Img = lists:nth(2, Node),
  ["<img src=\"", Img, "\" alt=\"\" />"];

transform2('Color', Node, _Index) ->
  Color = lists:nth(2, Node),
  Text = lists:nth(4, Node),
  ["<span style=\"color:", Color, "\">", Text, "</span>"];

transform2('ColorValue', Node, _Index) ->
  %% TODO: make sure passed values are either valid hex or gibberish
  %%       transform fff into #fff etc.
  [Node];

transform2('Size', Node, _Index) ->
  Size = lists:nth(2, Node),
  Text = lists:nth(4, Node),
  ["<span style=\"font-size:", Size, "px\">", Text, "</span>"];

transform2('Code', Node, _Index) ->
  Code = lists:nth(2, Node),
  ["<pre>", Code, "</pre>"];

transform2('Quote', Node, _Index) ->
  Quote = lists:nth(2, Node),
  ["<blockquote>", Quote, "</blockquote>"];

transform2('List', Node, _Index) ->
  Items = lists:nth(2, Node),
  ["<ul>", Items, "</ul>"];

transform2('ListItem', Node, _Index) ->
  Item = lists:nth(2, Node),
  ["<li>", Item, "</li>"];

transform2('Table', Node, _Index) ->
  Rows = lists:nth(2, Node),
  ["<table>", Rows, "</table>"];

transform2('TableHeader', Node, _Index) ->
  Head = lists:nth(2, Node),
  ["<thead>", Head, "</thead>"];

transform2('TableRows', Node, _Index) ->
  Head = lists:nth(1, Node),
  Body = lists:nth(2, Node),
  [Head, "<tbody>", Body, "</tbody>"];

transform2('TableRow', Node, _Index) ->
  Cells = lists:nth(2, Node),
  ["<tr>", Cells, "</tr>"];

transform2('TableCellRegular', Node, _Index) ->
  Contents = lists:nth(2, Node),
  ["<td>", Contents, "</td>"];

transform2('TableCellHeader', Node, _Index) ->
  Contents = lists:nth(2, Node),
  ["<th>", Contents, "</th>"];


transform2('Any', Node, _Index) ->
  [Node];

transform2(Symbol, Node, _Index) when is_atom(Symbol) ->
  [Node].
  
%%
%% PEG grammar for BBCode
%%

%	Doc <- StartList (Block / Inline)*; 
%	 
%	Inline <- Style / Url / UrlTag / Img / .; 
%	Block <- Quote / Code / List / Table; 
%	 
%	Style <- Strong / Em / Underline / Strike / Color / Size; 
%	 
%	Strong <- StrongStart (!StrongEnd Inline)+ StrongEnd; 
%	StrongStart <- "[b]" / "[B]"; 
%	StrongEnd <- "[/b]" / "[/B]"; 
%	 
%	Em <- EmStart (!EmEnd Inline)+ EmEnd; 
%	EmStart <- "[i]" / "[I]"; 
%	EmEnd <- "[/i]" / "[/I]"; 
%	 
%	Underline <- UnderlineStart (!UnderlineEnd Inline)+ UnderlineEnd; 
%	UnderlineStart <- "[u]" / "[U]"; 
%	UnderlineEnd <- "[/u]" / "[/U]"; 
%	 
%	Strike <- StrikeStart (!StrikeEnd Inline)+ StrikeEnd; 
%	StrikeStart <- "[s]" / "[S]"; 
%	StrikeEnd <- "[/s]" / "[/S]"; 
%	 
%	Url <- UrlStart (!UrlEnd Inline)+ UrlEnd; 
%	UrlStart <- "[" ("u" / "U") ("r" / "R") ("l" / "L") "]"; 
%	UrlEnd <- "[/" ("u" / "U") ("r" / "R") ("l" / "L") "]"; 
%	 
%	UrlTag <- UrlTagStart (!"]" .)* "]" (!UrlEnd Inline)* UrlEnd; 
%	UrlTagStart <- "[" ("u" / "U") ("r" / "R") ("l" / "L") "="; 
%	 
%	Color <- ColorStart ColorValue "]" (!ColorEnd Inline)* ColorEnd; 
%	ColorStart <- "[" ("c" / "C") ("o" / "O") ("l" / "L")  ("o" / "O") ("r" / "R") "="; 
%	ColorEnd <- "[/" ("c" / "C") ("o" / "O") ("l" / "L")  ("o" / "O") ("r" / "R") "]"; 
%	ColorValue <- "#"? (!"]" .)+; 
%	 
%	Size <- SizeStart SizeValue "]" (!SizeEnd Inline)* SizeEnd; 
%	SizeStart <- "[" ("s" / "S") ("i" / "I") ("z" / "Z")  ("e" / "E") "="; 
%	SizeEnd <- "[/" ("s" / "S") ("i" / "I") ("z" / "Z")  ("e" / "E") "]"; 
%	SizeValue <- (!"]" .)+; 
%	 
%	Img <- ImgStart (!ImgEnd Inline)+ ImgEnd; 
%	ImgStart <- "[" ("i" / "I") ("m" / "M") ("g" / "G") "]"; 
%	ImgEnd <- "[/" ("i" / "I") ("m" / "M") ("g" / "G") "]"; 
%	 
%	Code <- CodeStart (!CodeEnd .)+ CodeEnd; 
%	CodeStart <- "[" ("c" / "C") ("o" / "O") ("d" / "D") ("e" / "E") "]"; 
%	CodeEnd <- "[/" ("c" / "C") ("o" / "O") ("d" / "D") ("e" / "E") "]"; 
%	 
%	Quote <- QuoteStart (!QuoteEnd Inline)+ QuoteEnd; 
%	QuoteStart <- "[" ("q" / "Q") ("u" / "U") ("o" / "O") ("t" / "T") ("e" / "E") "]"; 
%	QuoteEnd <- "[/" ("q" / "Q") ("u" / "U") ("o" / "O") ("t" / "T") ("e" / "E") "]"; 
%	 
%	List <- ListStart ListItems ListEnd; 
%	ListStart <- "[" ("l" / "L") ("i" / "I") ("s" / "S") ("t" / "T") "]"; 
%	ListEnd <- "[/" ("l" / "L") ("i" / "I") ("s" / "S") ("t" / "T") "]"; 
%	ListItems <- (ListItem / NewLine)*; 
%	ListItem <- "[*]" (!("[*]" / ListEnd) Inline)*; 
%	 
%	Table <- TableStart TableRows TableEnd; 
%	TableStart <- "[" ("t" / "T") ("a" / "A") ("b" / "B") ("l" / "L") ("e" / "E") "]"; 
%	TableEnd <- "[/" ("t" / "T") ("a" / "A") ("b" / "B") ("l" / "L") ("e" / "E") "]"; 
%	 
%	TableRows <- TableHeader? TableRow*; 
%	 
%	TableHeader <- TableHeaderStart (!TableHeaderEnd TableRow)* TableHeaderEnd; 
%	TableHeaderStart <- "[" ("t" / "T") ("h" / "H") ("e" / "E") ("a" / "A") ("d" / "D") "]"; 
%	TableHeaderEnd <- "[/" ("t" / "T") ("h" / "H") ("e" / "E") ("a" / "A") ("d" / "D") "]"; 
%	 
%	TableRow <- TableRowStart TableRowCells TableRowEnd; 
%	TableRowStart <- "[" ("t" / "T") ("r" / "R") "]"; 
%	TableRowEnd <- "[/" ("t" / "T") ("r" / "R") "]"; 
%	 
%	TableRowCells <- TableCell*; 
%	TableCell <- TableCellRegular / TableCellHeader; 
%	 
%	TableCellRegular <- TableCellRegularStart (!TableCellRegularEnd TableCellContents)* TableCellRegularEnd; 
%	TableCellRegularStart <- "[" ("t" / "T") ("d" / "D") "]"; 
%	TableCellRegularEnd <- "[/" ("t" / "T") ("d" / "D") "]"; 
%	 
%	TableCellHeader <- TableCellHeaderStart (!TableCellHeaderEnd TableCellContents)* TableCellHeaderEnd; 
%	TableCellHeaderStart <- "[" ("t" / "T") ("h" / "H") "]"; 
%	TableCellHeaderEnd <- "[/" ("t" / "T") ("h" / "H") "]"; 
%	 
%	TableCellContents <- Quote / List / Code / Inline / .; 
%	 
%	NewLine <- "\n" / "\r" "\n"?; 
%	 
%	StartList <- &.; 


%%
%% PEG parser generated by Neotoma
%%

parse(List) when is_list(List) -> parse(list_to_binary(List));
parse(Input) when is_binary(Input) ->
  setup_memo(),
  Result = case 'Doc'(Input,{{line,1},{column,1}}) of
             {AST, <<>>, _Index} -> AST;
             Any -> Any
           end,
  release_memo(), Result.

'Doc'(Input, Index) ->
  p(Input, Index, 'Doc', fun(I,D) -> (p_seq([fun 'StartList'/2, p_zero_or_more(p_choose([fun 'Block'/2, fun 'Inline'/2]))]))(I,D) end, fun(Node, Idx) -> transform('Doc', Node, Idx) end).

'Inline'(Input, Index) ->
  p(Input, Index, 'Inline', fun(I,D) -> (p_choose([fun 'Style'/2, fun 'Url'/2, fun 'UrlTag'/2, fun 'Img'/2, p_anything()]))(I,D) end, fun(Node, Idx) -> transform('Inline', Node, Idx) end).

'Block'(Input, Index) ->
  p(Input, Index, 'Block', fun(I,D) -> (p_choose([fun 'Quote'/2, fun 'Code'/2, fun 'List'/2, fun 'Table'/2]))(I,D) end, fun(Node, Idx) -> transform('Block', Node, Idx) end).

'Style'(Input, Index) ->
  p(Input, Index, 'Style', fun(I,D) -> (p_choose([fun 'Strong'/2, fun 'Em'/2, fun 'Underline'/2, fun 'Strike'/2, fun 'Color'/2, fun 'Size'/2]))(I,D) end, fun(Node, Idx) -> transform('Style', Node, Idx) end).

'Strong'(Input, Index) ->
  p(Input, Index, 'Strong', fun(I,D) -> (p_seq([fun 'StrongStart'/2, p_one_or_more(p_seq([p_not(fun 'StrongEnd'/2), fun 'Inline'/2])), fun 'StrongEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('Strong', Node, Idx) end).

'StrongStart'(Input, Index) ->
  p(Input, Index, 'StrongStart', fun(I,D) -> (p_choose([p_string(<<"[b]">>), p_string(<<"[B]">>)]))(I,D) end, fun(Node, Idx) -> transform('StrongStart', Node, Idx) end).

'StrongEnd'(Input, Index) ->
  p(Input, Index, 'StrongEnd', fun(I,D) -> (p_choose([p_string(<<"[\/b]">>), p_string(<<"[\/B]">>)]))(I,D) end, fun(Node, Idx) -> transform('StrongEnd', Node, Idx) end).

'Em'(Input, Index) ->
  p(Input, Index, 'Em', fun(I,D) -> (p_seq([fun 'EmStart'/2, p_one_or_more(p_seq([p_not(fun 'EmEnd'/2), fun 'Inline'/2])), fun 'EmEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('Em', Node, Idx) end).

'EmStart'(Input, Index) ->
  p(Input, Index, 'EmStart', fun(I,D) -> (p_choose([p_string(<<"[i]">>), p_string(<<"[I]">>)]))(I,D) end, fun(Node, Idx) -> transform('EmStart', Node, Idx) end).

'EmEnd'(Input, Index) ->
  p(Input, Index, 'EmEnd', fun(I,D) -> (p_choose([p_string(<<"[\/i]">>), p_string(<<"[\/I]">>)]))(I,D) end, fun(Node, Idx) -> transform('EmEnd', Node, Idx) end).

'Underline'(Input, Index) ->
  p(Input, Index, 'Underline', fun(I,D) -> (p_seq([fun 'UnderlineStart'/2, p_one_or_more(p_seq([p_not(fun 'UnderlineEnd'/2), fun 'Inline'/2])), fun 'UnderlineEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('Underline', Node, Idx) end).

'UnderlineStart'(Input, Index) ->
  p(Input, Index, 'UnderlineStart', fun(I,D) -> (p_choose([p_string(<<"[u]">>), p_string(<<"[U]">>)]))(I,D) end, fun(Node, Idx) -> transform('UnderlineStart', Node, Idx) end).

'UnderlineEnd'(Input, Index) ->
  p(Input, Index, 'UnderlineEnd', fun(I,D) -> (p_choose([p_string(<<"[\/u]">>), p_string(<<"[\/U]">>)]))(I,D) end, fun(Node, Idx) -> transform('UnderlineEnd', Node, Idx) end).

'Strike'(Input, Index) ->
  p(Input, Index, 'Strike', fun(I,D) -> (p_seq([fun 'StrikeStart'/2, p_one_or_more(p_seq([p_not(fun 'StrikeEnd'/2), fun 'Inline'/2])), fun 'StrikeEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('Strike', Node, Idx) end).

'StrikeStart'(Input, Index) ->
  p(Input, Index, 'StrikeStart', fun(I,D) -> (p_choose([p_string(<<"[s]">>), p_string(<<"[S]">>)]))(I,D) end, fun(Node, Idx) -> transform('StrikeStart', Node, Idx) end).

'StrikeEnd'(Input, Index) ->
  p(Input, Index, 'StrikeEnd', fun(I,D) -> (p_choose([p_string(<<"[\/s]">>), p_string(<<"[\/S]">>)]))(I,D) end, fun(Node, Idx) -> transform('StrikeEnd', Node, Idx) end).

'Url'(Input, Index) ->
  p(Input, Index, 'Url', fun(I,D) -> (p_seq([fun 'UrlStart'/2, p_one_or_more(p_seq([p_not(fun 'UrlEnd'/2), fun 'Inline'/2])), fun 'UrlEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('Url', Node, Idx) end).

'UrlStart'(Input, Index) ->
  p(Input, Index, 'UrlStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"u">>), p_string(<<"U">>)]), p_choose([p_string(<<"r">>), p_string(<<"R">>)]), p_choose([p_string(<<"l">>), p_string(<<"L">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('UrlStart', Node, Idx) end).

'UrlEnd'(Input, Index) ->
  p(Input, Index, 'UrlEnd', fun(I,D) -> (p_seq([p_string(<<"[\/">>), p_choose([p_string(<<"u">>), p_string(<<"U">>)]), p_choose([p_string(<<"r">>), p_string(<<"R">>)]), p_choose([p_string(<<"l">>), p_string(<<"L">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('UrlEnd', Node, Idx) end).

'UrlTag'(Input, Index) ->
  p(Input, Index, 'UrlTag', fun(I,D) -> (p_seq([fun 'UrlTagStart'/2, p_zero_or_more(p_seq([p_not(p_string(<<"]">>)), p_anything()])), p_string(<<"]">>), p_zero_or_more(p_seq([p_not(fun 'UrlEnd'/2), fun 'Inline'/2])), fun 'UrlEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('UrlTag', Node, Idx) end).

'UrlTagStart'(Input, Index) ->
  p(Input, Index, 'UrlTagStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"u">>), p_string(<<"U">>)]), p_choose([p_string(<<"r">>), p_string(<<"R">>)]), p_choose([p_string(<<"l">>), p_string(<<"L">>)]), p_string(<<"=">>)]))(I,D) end, fun(Node, Idx) -> transform('UrlTagStart', Node, Idx) end).

'Color'(Input, Index) ->
  p(Input, Index, 'Color', fun(I,D) -> (p_seq([fun 'ColorStart'/2, fun 'ColorValue'/2, p_string(<<"]">>), p_zero_or_more(p_seq([p_not(fun 'ColorEnd'/2), fun 'Inline'/2])), fun 'ColorEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('Color', Node, Idx) end).

'ColorStart'(Input, Index) ->
  p(Input, Index, 'ColorStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"c">>), p_string(<<"C">>)]), p_choose([p_string(<<"o">>), p_string(<<"O">>)]), p_choose([p_string(<<"l">>), p_string(<<"L">>)]), p_choose([p_string(<<"o">>), p_string(<<"O">>)]), p_choose([p_string(<<"r">>), p_string(<<"R">>)]), p_string(<<"=">>)]))(I,D) end, fun(Node, Idx) -> transform('ColorStart', Node, Idx) end).

'ColorEnd'(Input, Index) ->
  p(Input, Index, 'ColorEnd', fun(I,D) -> (p_seq([p_string(<<"[\/">>), p_choose([p_string(<<"c">>), p_string(<<"C">>)]), p_choose([p_string(<<"o">>), p_string(<<"O">>)]), p_choose([p_string(<<"l">>), p_string(<<"L">>)]), p_choose([p_string(<<"o">>), p_string(<<"O">>)]), p_choose([p_string(<<"r">>), p_string(<<"R">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('ColorEnd', Node, Idx) end).

'ColorValue'(Input, Index) ->
  p(Input, Index, 'ColorValue', fun(I,D) -> (p_seq([p_optional(p_string(<<"#">>)), p_one_or_more(p_seq([p_not(p_string(<<"]">>)), p_anything()]))]))(I,D) end, fun(Node, Idx) -> transform('ColorValue', Node, Idx) end).

'Size'(Input, Index) ->
  p(Input, Index, 'Size', fun(I,D) -> (p_seq([fun 'SizeStart'/2, fun 'SizeValue'/2, p_string(<<"]">>), p_zero_or_more(p_seq([p_not(fun 'SizeEnd'/2), fun 'Inline'/2])), fun 'SizeEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('Size', Node, Idx) end).

'SizeStart'(Input, Index) ->
  p(Input, Index, 'SizeStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"s">>), p_string(<<"S">>)]), p_choose([p_string(<<"i">>), p_string(<<"I">>)]), p_choose([p_string(<<"z">>), p_string(<<"Z">>)]), p_choose([p_string(<<"e">>), p_string(<<"E">>)]), p_string(<<"=">>)]))(I,D) end, fun(Node, Idx) -> transform('SizeStart', Node, Idx) end).

'SizeEnd'(Input, Index) ->
  p(Input, Index, 'SizeEnd', fun(I,D) -> (p_seq([p_string(<<"[\/">>), p_choose([p_string(<<"s">>), p_string(<<"S">>)]), p_choose([p_string(<<"i">>), p_string(<<"I">>)]), p_choose([p_string(<<"z">>), p_string(<<"Z">>)]), p_choose([p_string(<<"e">>), p_string(<<"E">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('SizeEnd', Node, Idx) end).

'SizeValue'(Input, Index) ->
  p(Input, Index, 'SizeValue', fun(I,D) -> (p_one_or_more(p_seq([p_not(p_string(<<"]">>)), p_anything()])))(I,D) end, fun(Node, Idx) -> transform('SizeValue', Node, Idx) end).

'Img'(Input, Index) ->
  p(Input, Index, 'Img', fun(I,D) -> (p_seq([fun 'ImgStart'/2, p_one_or_more(p_seq([p_not(fun 'ImgEnd'/2), fun 'Inline'/2])), fun 'ImgEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('Img', Node, Idx) end).

'ImgStart'(Input, Index) ->
  p(Input, Index, 'ImgStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"i">>), p_string(<<"I">>)]), p_choose([p_string(<<"m">>), p_string(<<"M">>)]), p_choose([p_string(<<"g">>), p_string(<<"G">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('ImgStart', Node, Idx) end).

'ImgEnd'(Input, Index) ->
  p(Input, Index, 'ImgEnd', fun(I,D) -> (p_seq([p_string(<<"[\/">>), p_choose([p_string(<<"i">>), p_string(<<"I">>)]), p_choose([p_string(<<"m">>), p_string(<<"M">>)]), p_choose([p_string(<<"g">>), p_string(<<"G">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('ImgEnd', Node, Idx) end).

'Code'(Input, Index) ->
  p(Input, Index, 'Code', fun(I,D) -> (p_seq([fun 'CodeStart'/2, p_one_or_more(p_seq([p_not(fun 'CodeEnd'/2), p_anything()])), fun 'CodeEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('Code', Node, Idx) end).

'CodeStart'(Input, Index) ->
  p(Input, Index, 'CodeStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"c">>), p_string(<<"C">>)]), p_choose([p_string(<<"o">>), p_string(<<"O">>)]), p_choose([p_string(<<"d">>), p_string(<<"D">>)]), p_choose([p_string(<<"e">>), p_string(<<"E">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('CodeStart', Node, Idx) end).

'CodeEnd'(Input, Index) ->
  p(Input, Index, 'CodeEnd', fun(I,D) -> (p_seq([p_string(<<"[\/">>), p_choose([p_string(<<"c">>), p_string(<<"C">>)]), p_choose([p_string(<<"o">>), p_string(<<"O">>)]), p_choose([p_string(<<"d">>), p_string(<<"D">>)]), p_choose([p_string(<<"e">>), p_string(<<"E">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('CodeEnd', Node, Idx) end).

'Quote'(Input, Index) ->
  p(Input, Index, 'Quote', fun(I,D) -> (p_seq([fun 'QuoteStart'/2, p_one_or_more(p_seq([p_not(fun 'QuoteEnd'/2), fun 'Inline'/2])), fun 'QuoteEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('Quote', Node, Idx) end).

'QuoteStart'(Input, Index) ->
  p(Input, Index, 'QuoteStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"q">>), p_string(<<"Q">>)]), p_choose([p_string(<<"u">>), p_string(<<"U">>)]), p_choose([p_string(<<"o">>), p_string(<<"O">>)]), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_choose([p_string(<<"e">>), p_string(<<"E">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('QuoteStart', Node, Idx) end).

'QuoteEnd'(Input, Index) ->
  p(Input, Index, 'QuoteEnd', fun(I,D) -> (p_seq([p_string(<<"[\/">>), p_choose([p_string(<<"q">>), p_string(<<"Q">>)]), p_choose([p_string(<<"u">>), p_string(<<"U">>)]), p_choose([p_string(<<"o">>), p_string(<<"O">>)]), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_choose([p_string(<<"e">>), p_string(<<"E">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('QuoteEnd', Node, Idx) end).

'List'(Input, Index) ->
  p(Input, Index, 'List', fun(I,D) -> (p_seq([fun 'ListStart'/2, fun 'ListItems'/2, fun 'ListEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('List', Node, Idx) end).

'ListStart'(Input, Index) ->
  p(Input, Index, 'ListStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"l">>), p_string(<<"L">>)]), p_choose([p_string(<<"i">>), p_string(<<"I">>)]), p_choose([p_string(<<"s">>), p_string(<<"S">>)]), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('ListStart', Node, Idx) end).

'ListEnd'(Input, Index) ->
  p(Input, Index, 'ListEnd', fun(I,D) -> (p_seq([p_string(<<"[\/">>), p_choose([p_string(<<"l">>), p_string(<<"L">>)]), p_choose([p_string(<<"i">>), p_string(<<"I">>)]), p_choose([p_string(<<"s">>), p_string(<<"S">>)]), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('ListEnd', Node, Idx) end).

'ListItems'(Input, Index) ->
  p(Input, Index, 'ListItems', fun(I,D) -> (p_zero_or_more(p_choose([fun 'ListItem'/2, fun 'NewLine'/2])))(I,D) end, fun(Node, Idx) -> transform('ListItems', Node, Idx) end).

'ListItem'(Input, Index) ->
  p(Input, Index, 'ListItem', fun(I,D) -> (p_seq([p_string(<<"[*]">>), p_zero_or_more(p_seq([p_not(p_choose([p_string(<<"[*]">>), fun 'ListEnd'/2])), fun 'Inline'/2]))]))(I,D) end, fun(Node, Idx) -> transform('ListItem', Node, Idx) end).

'Table'(Input, Index) ->
  p(Input, Index, 'Table', fun(I,D) -> (p_seq([fun 'TableStart'/2, fun 'TableRows'/2, fun 'TableEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('Table', Node, Idx) end).

'TableStart'(Input, Index) ->
  p(Input, Index, 'TableStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_choose([p_string(<<"a">>), p_string(<<"A">>)]), p_choose([p_string(<<"b">>), p_string(<<"B">>)]), p_choose([p_string(<<"l">>), p_string(<<"L">>)]), p_choose([p_string(<<"e">>), p_string(<<"E">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('TableStart', Node, Idx) end).

'TableEnd'(Input, Index) ->
  p(Input, Index, 'TableEnd', fun(I,D) -> (p_seq([p_string(<<"[\/">>), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_choose([p_string(<<"a">>), p_string(<<"A">>)]), p_choose([p_string(<<"b">>), p_string(<<"B">>)]), p_choose([p_string(<<"l">>), p_string(<<"L">>)]), p_choose([p_string(<<"e">>), p_string(<<"E">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('TableEnd', Node, Idx) end).

'TableRows'(Input, Index) ->
  p(Input, Index, 'TableRows', fun(I,D) -> (p_seq([p_optional(fun 'TableHeader'/2), p_zero_or_more(fun 'TableRow'/2)]))(I,D) end, fun(Node, Idx) -> transform('TableRows', Node, Idx) end).

'TableHeader'(Input, Index) ->
  p(Input, Index, 'TableHeader', fun(I,D) -> (p_seq([fun 'TableHeaderStart'/2, p_zero_or_more(p_seq([p_not(fun 'TableHeaderEnd'/2), fun 'TableRow'/2])), fun 'TableHeaderEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('TableHeader', Node, Idx) end).

'TableHeaderStart'(Input, Index) ->
  p(Input, Index, 'TableHeaderStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_choose([p_string(<<"h">>), p_string(<<"H">>)]), p_choose([p_string(<<"e">>), p_string(<<"E">>)]), p_choose([p_string(<<"a">>), p_string(<<"A">>)]), p_choose([p_string(<<"d">>), p_string(<<"D">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('TableHeaderStart', Node, Idx) end).

'TableHeaderEnd'(Input, Index) ->
  p(Input, Index, 'TableHeaderEnd', fun(I,D) -> (p_seq([p_string(<<"[\/">>), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_choose([p_string(<<"h">>), p_string(<<"H">>)]), p_choose([p_string(<<"e">>), p_string(<<"E">>)]), p_choose([p_string(<<"a">>), p_string(<<"A">>)]), p_choose([p_string(<<"d">>), p_string(<<"D">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('TableHeaderEnd', Node, Idx) end).

'TableRow'(Input, Index) ->
  p(Input, Index, 'TableRow', fun(I,D) -> (p_seq([fun 'TableRowStart'/2, fun 'TableRowCells'/2, fun 'TableRowEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('TableRow', Node, Idx) end).

'TableRowStart'(Input, Index) ->
  p(Input, Index, 'TableRowStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_choose([p_string(<<"r">>), p_string(<<"R">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('TableRowStart', Node, Idx) end).

'TableRowEnd'(Input, Index) ->
  p(Input, Index, 'TableRowEnd', fun(I,D) -> (p_seq([p_string(<<"[\/">>), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_choose([p_string(<<"r">>), p_string(<<"R">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('TableRowEnd', Node, Idx) end).

'TableRowCells'(Input, Index) ->
  p(Input, Index, 'TableRowCells', fun(I,D) -> (p_zero_or_more(fun 'TableCell'/2))(I,D) end, fun(Node, Idx) -> transform('TableRowCells', Node, Idx) end).

'TableCell'(Input, Index) ->
  p(Input, Index, 'TableCell', fun(I,D) -> (p_choose([fun 'TableCellRegular'/2, fun 'TableCellHeader'/2]))(I,D) end, fun(Node, Idx) -> transform('TableCell', Node, Idx) end).

'TableCellRegular'(Input, Index) ->
  p(Input, Index, 'TableCellRegular', fun(I,D) -> (p_seq([fun 'TableCellRegularStart'/2, p_zero_or_more(p_seq([p_not(fun 'TableCellRegularEnd'/2), fun 'TableCellContents'/2])), fun 'TableCellRegularEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('TableCellRegular', Node, Idx) end).

'TableCellRegularStart'(Input, Index) ->
  p(Input, Index, 'TableCellRegularStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_choose([p_string(<<"d">>), p_string(<<"D">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('TableCellRegularStart', Node, Idx) end).

'TableCellRegularEnd'(Input, Index) ->
  p(Input, Index, 'TableCellRegularEnd', fun(I,D) -> (p_seq([p_string(<<"[\/">>), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_choose([p_string(<<"d">>), p_string(<<"D">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('TableCellRegularEnd', Node, Idx) end).

'TableCellHeader'(Input, Index) ->
  p(Input, Index, 'TableCellHeader', fun(I,D) -> (p_seq([fun 'TableCellHeaderStart'/2, p_zero_or_more(p_seq([p_not(fun 'TableCellHeaderEnd'/2), fun 'TableCellContents'/2])), fun 'TableCellHeaderEnd'/2]))(I,D) end, fun(Node, Idx) -> transform('TableCellHeader', Node, Idx) end).

'TableCellHeaderStart'(Input, Index) ->
  p(Input, Index, 'TableCellHeaderStart', fun(I,D) -> (p_seq([p_string(<<"[">>), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_choose([p_string(<<"h">>), p_string(<<"H">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('TableCellHeaderStart', Node, Idx) end).

'TableCellHeaderEnd'(Input, Index) ->
  p(Input, Index, 'TableCellHeaderEnd', fun(I,D) -> (p_seq([p_string(<<"[\/">>), p_choose([p_string(<<"t">>), p_string(<<"T">>)]), p_choose([p_string(<<"h">>), p_string(<<"H">>)]), p_string(<<"]">>)]))(I,D) end, fun(Node, Idx) -> transform('TableCellHeaderEnd', Node, Idx) end).

'TableCellContents'(Input, Index) ->
  p(Input, Index, 'TableCellContents', fun(I,D) -> (p_choose([fun 'Quote'/2, fun 'List'/2, fun 'Code'/2, fun 'Inline'/2, p_anything()]))(I,D) end, fun(Node, Idx) -> transform('TableCellContents', Node, Idx) end).

'NewLine'(Input, Index) ->
  p(Input, Index, 'NewLine', fun(I,D) -> (p_choose([p_string(<<"\n">>), p_seq([p_string(<<"\r">>), p_optional(p_string(<<"\n">>))])]))(I,D) end, fun(Node, Idx) -> transform('NewLine', Node, Idx) end).

'StartList'(Input, Index) ->
  p(Input, Index, 'StartList', fun(I,D) -> (p_assert(p_anything()))(I,D) end, fun(Node, Idx) -> transform('StartList', Node, Idx) end).


transform(Symbol,Node,Index) -> transform1(Symbol, Node, Index).

p(Inp, Index, Name, ParseFun) ->
  p(Inp, Index, Name, ParseFun, fun(N, _Idx) -> N end).

p(Inp, StartIndex, Name, ParseFun, TransformFun) ->
  case get_memo(StartIndex, Name) of      % See if the current reduction is memoized
    {ok, Memo} -> %Memo;                     % If it is, return the stored result
      Memo;
    _ ->                                        % If not, attempt to parse
      case ParseFun(Inp, StartIndex) of
        {fail,_} = Failure ->                       % If it fails, memoize the failure
          Result = Failure;
        {Match, InpRem, NewIndex} ->               % If it passes, transform and memoize the result.
          Transformed = TransformFun(Match, StartIndex),
          Result = {Transformed, InpRem, NewIndex}
      end,
      memoize(StartIndex, Name, Result),
      Result
  end.

setup_memo() ->
  put(parse_memo_table, ets:new(?MODULE, [set])).

release_memo() ->
  ets:delete(memo_table_name()).

memoize(Index, Name, Result) ->
  Memo = case ets:lookup(memo_table_name(), Index) of
              [] -> [];
              [{Index, Plist}] -> Plist
         end,
  ets:insert(memo_table_name(), {Index, [{Name, Result}|Memo]}).

get_memo(Index, Name) ->
  case ets:lookup(memo_table_name(), Index) of
    [] -> {error, not_found};
    [{Index, Plist}] ->
      case proplists:lookup(Name, Plist) of
        {Name, Result}  -> {ok, Result};
        _  -> {error, not_found}
      end
    end.

memo_table_name() ->
    get(parse_memo_table).

p_eof() ->
  fun(<<>>, Index) -> {eof, [], Index};
     (_, Index) -> {fail, {expected, eof, Index}} end.

p_optional(P) ->
  fun(Input, Index) ->
      case P(Input, Index) of
        {fail,_} -> {[], Input, Index};
        {_, _, _} = Success -> Success
      end
  end.

p_not(P) ->
  fun(Input, Index)->
      case P(Input,Index) of
        {fail,_} ->
          {[], Input, Index};
        {Result, _, _} -> {fail, {expected, {no_match, Result},Index}}
      end
  end.

p_assert(P) ->
  fun(Input,Index) ->
      case P(Input,Index) of
        {fail,_} = Failure-> Failure;
        _ -> {[], Input, Index}
      end
  end.

p_and(P) ->
  p_seq(P).

p_seq(P) ->
  fun(Input, Index) ->
      p_all(P, Input, Index, [])
  end.

p_all([], Inp, Index, Accum ) -> {lists:reverse( Accum ), Inp, Index};
p_all([P|Parsers], Inp, Index, Accum) ->
  case P(Inp, Index) of
    {fail, _} = Failure -> Failure;
    {Result, InpRem, NewIndex} -> p_all(Parsers, InpRem, NewIndex, [Result|Accum])
  end.

p_choose(Parsers) ->
  fun(Input, Index) ->
      p_attempt(Parsers, Input, Index, none)
  end.

p_attempt([], _Input, _Index, Failure) -> Failure;
p_attempt([P|Parsers], Input, Index, FirstFailure)->
  case P(Input, Index) of
    {fail, _} = Failure ->
      case FirstFailure of
        none -> p_attempt(Parsers, Input, Index, Failure);
        _ -> p_attempt(Parsers, Input, Index, FirstFailure)
      end;
    Result -> Result
  end.

p_zero_or_more(P) ->
  fun(Input, Index) ->
      p_scan(P, Input, Index, [])
  end.

p_one_or_more(P) ->
  fun(Input, Index)->
      Result = p_scan(P, Input, Index, []),
      case Result of
        {[_|_], _, _} ->
          Result;
        _ ->
          {fail, {expected, Failure, _}} = P(Input,Index),
          {fail, {expected, {at_least_one, Failure}, Index}}
      end
  end.

p_label(Tag, P) ->
  fun(Input, Index) ->
      case P(Input, Index) of
        {fail,_} = Failure ->
           Failure;
        {Result, InpRem, NewIndex} ->
          {{Tag, Result}, InpRem, NewIndex}
      end
  end.

p_scan(_, [], Index, Accum) -> {lists:reverse( Accum ), [], Index};
p_scan(P, Inp, Index, Accum) ->
  case P(Inp, Index) of
    {fail,_} -> {lists:reverse(Accum), Inp, Index};
    {Result, InpRem, NewIndex} -> p_scan(P, InpRem, NewIndex, [Result | Accum])
  end.

p_string(S) when is_list(S) -> p_string(list_to_binary(S));
p_string(S) ->
    Length = erlang:byte_size(S),
    fun(Input, Index) ->
      try
          <<S:Length/binary, Rest/binary>> = Input,
          {S, Rest, p_advance_index(S, Index)}
      catch
          error:{badmatch,_} -> {fail, {expected, {string, S}, Index}}
      end
    end.

p_anything() ->
  fun(<<>>, Index) -> {fail, {expected, any_character, Index}};
     (Input, Index) when is_binary(Input) ->
          <<C/utf8, Rest/binary>> = Input,
          {<<C/utf8>>, Rest, p_advance_index(<<C/utf8>>, Index)}
  end.

p_charclass(Class) ->
    {ok, RE} = re:compile(Class, [unicode, dotall]),
    fun(Inp, Index) ->
            case re:run(Inp, RE, [anchored]) of
                {match, [{0, Length}|_]} ->
                    {Head, Tail} = erlang:split_binary(Inp, Length),
                    {Head, Tail, p_advance_index(Head, Index)};
                _ -> {fail, {expected, {character_class, binary_to_list(Class)}, Index}}
            end
    end.

line({{line,L},_}) -> L;
line(_) -> undefined.

column({_,{column,C}}) -> C;
column(_) -> undefined.

p_advance_index(MatchedInput, Index) when is_list(MatchedInput) orelse is_binary(MatchedInput)-> % strings
  lists:foldl(fun p_advance_index/2, Index, unicode:characters_to_list(MatchedInput));
p_advance_index(MatchedInput, Index) when is_integer(MatchedInput) -> % single characters
  {{line, Line}, {column, Col}} = Index,
  case MatchedInput of
    $\n -> {{line, Line+1}, {column, 1}};
    _ -> {{line, Line}, {column, Col+1}}
  end.
